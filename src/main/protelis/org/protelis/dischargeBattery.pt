module org:protelis:dischargeBattery
import it.nicolasfarabegoli.pulverization.interop.ProtelisInterop.onBatteryChangeEvent

def mAhToJ(mAh) = mAh * 3300 / 3600 // V * A * s
def mAToW(mA) = mA * 3300 / 3600 // V * A

/**
 * Given the [currentCharge] the function discharge the battery accordingly.
 * @returns the new charge.
 */
def discharge(currentCharge, delta) {
    let behaviourDischargeRate = env.get("behaviourDischargeRate")
    let communicationDischargeRate = env.get("communicationDischargeRate")
    let sensorsDischargeRate = env.get("sensorsDischargeRate")
    let intraComponentCommCost = env.get("intraComponentCommCost")

    let behaviourInDevice = env.get("behaviourInDevice")

    let intraCommCosts = intraComponentCost(behaviourInDevice, true, true)
    let behaviourCost = if (behaviourInDevice) { behaviourDischargeRate } else { 0.0 }

    let sumCosts = intraCommCosts + behaviourCost + communicationDischargeRate + sensorsDischargeRate + random(env.get("defaultDeviceConsumption"));
    env.put("batteryConsumption", mAhToJ(sumCosts) / delta)
    let newCharge = currentCharge - (sumCosts * delta / 3600.0)

    let currentPercentage = toPercentage(newCharge, env.get("maxBatteryCapacity"))
    if (currentPercentage <= env.get("personalStartChargeThreshold")) {
        env.put("isCharging", true)
        toCharge(env.get("personalStartChargeThreshold"), env.get("maxBatteryCapacity"))
    } else { newCharge }
}

/**
 * Determines the communication cost based on the local active components.
 * @returns the cost for the communication between (remote) components.
 */
def intraComponentCost(bhvLocal, commLocal, sensLocal) {
    let intraComponentCommCost = env.get("intraComponentCommCost")
    if (bhvLocal) {
        if (!commLocal) { intraComponentCommCost } else { 0.0 } + if (!sensLocal) { intraComponentCommCost } else { 0.0 }
    } else {
        if (commLocal) { intraComponentCommCost } else { 0.0 } + if (sensLocal) { intraComponentCommCost } else { 0.0 }
    }
}

/**
 * Recharge the battery of the device
 */
def recharge(currentCharge, delta) {
    env.put("batteryConsumption", 0.0)
    let rechargeRate = env.get("rechargeRate")
    let addingCharge = rechargeRate * delta / 3600.0
    let currentPercentage = toPercentage(currentCharge, env.get("maxBatteryCapacity"))
    if (currentPercentage >= env.get("personalStopChargeThreshold")) {
        env.put("isCharging", false)
        toCharge(env.get("personalStopChargeThreshold"), env.get("maxBatteryCapacity"))
    } else { currentCharge + addingCharge }
}

def random(max) = self.nextRandomDouble() * max
def toPercentage(value, max) = value / max * 100.0
def toCharge(value, max) = value * max / 100.0

let now = self.getCurrentTime();

rep (still <- now) {
    let delta = now - still
    let isCharging = env.get("isCharging")
    let newCharge = if (isCharging) {
        recharge(env.get("currentCapacity"), delta)
    } else {
        discharge(env.get("currentCapacity"), delta)
    }
    env.put("currentCapacity", newCharge)
    let percentage = toPercentage(newCharge, env.get("maxBatteryCapacity"))
    env.put("batteryPercentage", percentage)
    onBatteryChangeEvent()
    now
}
