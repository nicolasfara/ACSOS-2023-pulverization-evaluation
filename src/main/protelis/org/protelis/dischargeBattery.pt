module org:protelis:dischargeBattery
import it.nicolasfarabegoli.pulverization.interop.ProtelisInterop.onBatteryChangeEvent

def wattToAmpere(watt, volts) = watt / volts
def jouleToWatt(joule, time) = joule / time

/**
 * Given the [currentCharge] the function discharge the battery accordingly.
 * @returns the new charge.
 */
def discharge(currentCharge, delta) {
    let deviceEPI = env.get("deviceEPI")
    let behaviourInstructions = env.get("behaviourInstructions")
    let communicationInstructions = env.get("communicationInstructions")
    let sensorsInstructions = env.get("sensorsInstructions")

    let behaviourInDevice = env.get("behaviourInDevice")
    let behaviourJoule = if (behaviourInDevice) { deviceEPI * behaviourInstructions } else { 0.0 }
    let behaviourWatt = jouleToWatt(behaviourJoule, delta)

    let communicationJoule = communicationInstructions * deviceEPI
    let communicationWatt = jouleToWatt(communicationJoule, delta)

    let sensorsJoule = sensorsInstructions * deviceEPI
    let sensorsWatt = jouleToWatt(sensorsJoule, delta)

    let intraCommJoule = intraCommEnergy(behaviourInDevice, true, true)
    let intraCommWatt = jouleToWatt(intraCommJoule, delta)

    let osJoule = random(env.get("osDeviceInstructions")) * deviceEPI
    let osWatt = jouleToWatt(osJoule, delta)

    let totalWatt = behaviourWatt + communicationWatt + sensorsWatt + intraCommWatt + osWatt
    let totalMilliAmpere = wattToAmpere(totalWatt, 3.3) * 1000.0 // 3.3 Volts of the battery device

    env.put("batteryConsumption", totalWatt)
    let newCharge = currentCharge - (totalMilliAmpere * delta / 3600.0)

    let currentPercentage = toPercentage(newCharge, env.get("maxBatteryCapacity"))
    if (currentPercentage <= env.get("personalStartChargeThreshold")) {
        env.put("isCharging", true)
        toCharge(env.get("personalStartChargeThreshold"), env.get("maxBatteryCapacity"))
    } else { newCharge }
}

/**
 * Determines the communication cost based on the local active components.
 * @returns the cost for the communication between (remote) components.
 */
def intraCommEnergy(bhvLocal, commLocal, sensLocal) {
    let intraCommInstructions = env.get("intraCommInstructions")
    let deviceEPI = env.get("deviceEPI")
    let instructions = if (bhvLocal) {
        if (!commLocal) { intraCommInstructions } else { 0.0 } + if (!sensLocal) { intraCommInstructions } else { 0.0 }
    } else {
        if (commLocal) { intraCommInstructions } else { 0.0 } + if (sensLocal) { intraCommInstructions } else { 0.0 }
    }
    instructions * deviceEPI
}

/**
 * Recharge the battery of the device
 */
def recharge(currentCharge, delta) {
    env.put("batteryConsumption", 0.0)
    let rechargeRate = env.get("rechargeRate")
    let addingCharge = rechargeRate * delta / 3600.0
    let currentPercentage = toPercentage(currentCharge, env.get("maxBatteryCapacity"))
    if (currentPercentage >= env.get("personalStopChargeThreshold")) {
        env.put("isCharging", false)
        toCharge(env.get("personalStopChargeThreshold"), env.get("maxBatteryCapacity"))
    } else { currentCharge + addingCharge }
}

def random(max) = self.nextRandomDouble() * max
def toPercentage(value, max) = value / max * 100.0
def toCharge(value, max) = value * max / 100.0

let now = self.getCurrentTime();

rep (still <- now) {
    let delta = now - still
    let isCharging = env.get("isCharging")
    let newCharge = if (isCharging || env.get("currentCapacity") < env.get("personalStartChargeThreshold")) {
        recharge(env.get("currentCapacity"), delta)
    } else {
        discharge(env.get("currentCapacity"), delta)
    }
    env.put("currentCapacity", newCharge)
    let percentage = toPercentage(newCharge, env.get("maxBatteryCapacity"))
    env.put("batteryPercentage", percentage)
    onBatteryChangeEvent()
    now
}
